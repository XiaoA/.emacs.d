* Lessons // Do a couple of console.logs
// console.log("Hello from myscript.js");
// console.log("Hello again!"); //This is not needed

/*
var name = prompt("What is your name?");
alert("Hello " + name);

name = "Nick"
console.log("The user's name is " + name);
*/

// If/Else
/*
console.log("Before");

var name = prompt("What is your name?");

if (name) {
    console.log("If block");
} else {
    console.log("Else block");
};


console.log("After");
*/

//Loops

//While Loops

/*
var counter = 10;

while(counter) {
    console.log('Hello World');
    console.log('Hi');
    counter = counter - 1;
}

while (prompt("What is your name?")) {
    console.log("Got your name ");
}

console.log("After");
*/

// For Loops

/*
for (var counter=10;counter; counter = counter - 1) {
    console.log("Hello World", counter);
}

*/

// JS Extra Credit

/*
Extra Credit
Fizz Buzz

Write a program that loops through the numbers 1 through 100. Each number should be printed to the console, using console.log(). However, if the number is a multiple of 3, don't print the number, instead print the word "fizz". If the number is a multiple of 5, print "buzz" instead of the number. If it is a multiple of 3 and a multiple of 5, print "fizzbuzz" instead of the number.

Hint. Use loops and if/else statments. In javascript the % is the modulo, or remainder operator. a % b evaluates to the remainder of a divided by b. 11 % 3 is equal to 2.
*/

// var counter = 1;

// while(counter < 101) {
//     if (counter % 3 === 0) {
// 	console.log("fizz");
//     } else if (counter % 5 === 0) {
// 	console.log("buzz");
//     } else if (counter % 3 === 0) {
// 	if (counter % 5 === 0) {
// 	console.log("fizzbuzz");
// 	}} else {
// 	console.log(counter);
// 	counter = counter + 1;
//     }
// }

// var counter = 1;

// while (counter < 101) {
//     if (counter % 3 === 0) {
// 	console.log("fizz");
//     } else if (counter % 5 === 0) {
// 	console.log("buzz");
//     } else if (counter % 3 === 0 && counter % 5 === 0) {
// 	console.log("fizzbuzz");
//     } else {
// 	console.log(counter);
//     }

//     counter = counter + 1;
// }

//this doesn't quite work for fizzbuzz...

//
//Arrays
//

 // var friends = ["Jonathan", "Joe", "Scott", "Dominic"];
 // console.log(friends);
 // console.log(friends.length);

// console.log(friends[0]);

// var friendNumber = 1;
// console.log(friends[friendNumber]);

// for(var i=0; i < friends.length; i+=1) {
//     console.log(friends[i]);
// }

//
// Objects
//

// var me = {
//     first_name: "Andrew",
//     last_name: "Buckingham",
//     "Employee Number": 1
    
// }

// me.first_name = "Drew";

// console.log(me.first_name);
// console.log(me.last_name);
// console.log(me["Employee Number"]);
// console.log(me);


// var key = "first_name"; 
// console["log"](me[key]);

// Extra Credit

// Try creating an object that represents you. Include all sorts of things about you, like your name as a string, and your favorite songs as an array. Explore how objects can be nested in other objects, and arrays.

//
//Functions
//

// var sayHello = function () {
//     var message = "Hello";
//     message = message + " World!";
//     console.log(message);
// }

// var debug = function (message) {
//     console.log("Debug", message);
// }

// sayHello();

// var x = 1;
// debug("x has been set");

// sayHello();

// var doubleNumber = function (num) {
//     return num * 2;    
// }

// debug(doubleNumber(7));

// x +=10;
// var y = 100;
// debug("x has been increased. y has been set.");

// sayHello();

//  Extra Credit

// Create a function that takes 3 arguments, a, b, and c. If a is an even number have the function return the string "even". Otherwise have the function return the string "odd"

// var extraCredit = function(a, b, c){
//     if(a % 2 === 0) {
// 	return("even.");
//     } else {
// 	return("odd.");
//     }
//     a = "2";
// }

// console.log(extraCredit);


//==
//
//Deep Dive: JavaScript Foundations
//
//==

/* JavaScript Foundations: Variables */

// var myDiv = document.getElementById('myDiv');
// myDiv.style.background = "black";
// myDiv.style.color = "white";


/* JavaScript Foundations: Variables */

// var color = "red";

// var myDiv = document.getElementById('myDiv');
// myDiv.style.background = "black";
// myDiv.style.color = "#ffffff";

// Valid Variables
// Starts with A - Z a - z _ $
// Continues with A-Z a-z 0-9 _ $

// var car = "Toyota";
// var Color = "blue";
// var _myVariable = "something";
// var $specialName = 1;
// var a58389 = "What is it?";


// Invalid Variable Names

// var 3colors = "red green blue";
// var winning% = "w30";
// var person-name = "Andrew";
// var @you = "You are awesome!"

// Reserved Words
// https://developer.mozilla.org/en/JavaScript/Reference/Reserved_Words

//
//Null and Undefined
//

//var myVar = "value"; --> var myVar; (Undefined)

// Testing for undefined variables
//var myVar;
//console.log(typeof myVar === "undefined"); //true


// var myVar;

// console.log(typeof myVar === "undefined"); //best practice
// console.log(myVar === undefined); //variable set by JS; could be messed up, so this is a dangerous practice.

// var x = null;

// if (x == null) {
//     console.log("if");
// } else {
//     console.log("else");
// }

// if (myVar == null) {
//     console.log("if");
// } else {
//     console.log("else");
// } 


// var undefined == null; // true
// var undefined === null; // false
// // In most cases, we want to use ===, but using == can be convenient for testing between null and undefined.


//
// Scope
//

// if(myVar === null){
//     console.log("If");
// } else {
//     console.log("Else");
// }

// Scope


// var world = "World!";

// Reminder: Functions allow us to store code into something we can use later.

// function sayHello() {
//     var hello = "Hello ";

//     function inner () {
// 	var extra = "There is more!"
// 	console.log(hello + world);
//     }

//     inner();
// }

// sayHello();

// console.log("world outside sayHello(): ", world);
// console.log("hello outside sayHello(): ", hello);


//
// Shadowing
//

// Shadowing = Defining a variable with a name that is already defined at a higher level of a scope.


var myColor = "blue";
console.log("myColor before myFunc()", myColor);

function myFunc () {
    // When shadowing, you must use 'var' to define the variable within the scope to avoid renaming the global variable value!

    // In fact, we can actually great global variables within a scoped function by leaving off the 'var'...for example, we could create a global variable, [ myNumber = "42"] within the function, and it would be available globally...unless we added 'var' to the beginning...

    // Make sure your variable definitions always have 'var' at the beginning! 
    //var myNumber = '42'; //Here, myNumber is scoped within the function.
    myNumber = '42'; // Here, myNumber is a global variable.
    var myColor = "yellow";
    console.log("myColor inside myFunc()", myColor);
}

myFunc();
console.log("myColor after myFunc()", myColor);
console.log("myNumber after myFunc()", myNumber);

// Variables are limited by their scope. In the example above, 'myColor inside myFunc()' is yellow, because that is the value within the 'myFunc()' function. However, outside of that function, it is blue, becuase the globlal variable 'myColor' is blue. Defining a variable within a function allows us to avoid accidentally overwriting a gloabl variable.


// Q1 = "Nick"

// var person = "Jim";

// function whosGotTheFunc() {
//     var person = "Andrew";
// }

// person = "Nick";

// whosGotTheFunc();
// console.log(person);

// console.log("answer two");

//Q2 = "Andrew" (because there's no 'var' in front of it; the global was reset.)

// var person = "Jim";

// function whosGotTheFunc() {
// 	person = "Andrew";
// }

// person = "Nick";

// whosGotTheFunc();

// console.log(person);

//
// Hoisting
//

function doSomething (doit) {
    var color = "blue";
    if(doit) {
	var color = "red";
	console.log("Color in if(){}", color);
	
    }
    console.log("color after if(){}", color);
}

//doSomething(false);
doSomething(true);


// Declare variables at the top of your file/function. If you declare a variable in the middle of an if statement, like the one above, JavaScript will treat it like this:

//function dosomething (doit) {
//    var color = "blue";
//    var number; // Looking four lines below, at the 'var number..' line...that assignment is unnessary. 
    // if (doit) {
    // 	var color = "red";
    // 	console.log("Color in if(){}, color");
    // 	/* var */ number = "42" // using 'var' here is unnessary, because JS will hoist the variable assignment to the top of the function.
//    }
//}

// Key Point: Always put variables at the top for ease of reading and also to declare them without making JS hoist them!

// You can also combine all variables onto one statement, even if it goes over several lines, by separating each variable with a comma, and ending the list with a semicolon. You can mix variables with/without initial values.

// function dosomething (doit) {
//     var color = "blue",
// 	number,
// 	name = Andrew;
//     if (doit) {
// 	var color = "red";
// 	console.log("Color in if(){}, color");
// 	/* var */ number = "42"
//     }
// }

var color = "red";

function example () {
  color = "blue";
}

example()

alert(color);
* Strings
** Basics
   [[file:js/js/strings.js][string.js]]
*** "" vs. ''
    - Essentially the same for strings, but be careful of apostrophes!
   #+BEGIN_SRC js
/* JavaScript Strings */


var statement = "This is Andrew's string";
console.log(statement);

var statement2 = 'He said "This is awesome"';
console.log(statement2);

var statement3 = 'He said \"This is Andrew\'s String\"';
console.log(statement3);
   #+END_SRC
** Escape Characters
   - \f
   - \m 
   - \n newline
   - \\ '\'
   - -t TAB

     #+BEGIN_SRC js
var multiline = "This is line 1\nThis is line 2\nThis \tis line 3";
console.log(multiline);
     
     #+END_SRC
** Concatenation
   #+BEGIN_SRC js
var part1 = "Hello ";
var part2 = "World!";
var whole = part1 + part2;
console.log(whole+ "!!!");

var multiline = "This is line 1\n" +
	"This is line 2\n" +
	"This \tis line 3";
// the '+' must be at the end of the line!

console.log(multiline);
   
   #+END_SRC
** Methods: Part 1
   "There are many methods that you can call on JavaScript to transform or get information about the string. In this video we will learn about some of the most important methods."

   - .length;
   - .indexOf("string");
   - .charAt()

     #+BEGIN_SRC js
// Methods: Part 1

var length = whole.length;
console.log(length); // 12
console.log(whole, length); // '"Hello World!" 12'

var index = whole.indexOf("World");
console.log(index); // 6 (Where 'World' exists; begins on the 6th character.

var index2 = whole.indexOf("world");
console.log(index2); // -1 (search is case sensitive!)

if (whole.indexOf("W") !== -1) {
    console.log("W exists in string");
} else {
    console.log("W does not exist");
}

console.log(whole.charAt(2));
     
     #+END_SRC
** Methods: Part 2
   More Methods:
   - .substr(start, length);
   - toLowerCase();
   - toUpperCase();

     #+BEGIN_SRC js
// Methods: Part 2

// "Hello World!"
var world = whole.substr(6, 5);
console.log(world); // World!

console.log(whole.toLowerCase());
console.log(whole.toUpperCase());
console.log(whole);
     
     #+END_SRC
** Comparing Strings
   "Sometimes we want to be able to sort strings, and to allow us to do this, JavaScript has rules for comparing strings, so that one string can be defined as "less than" or "greater than" another string. In this video we look at the rules for comparing strings in JavaScript"

   - we need 3 '=' here because sometimes JS might change operands to make it true (e.g., 13 = 'thirteen'). So we'll usually want to use '===' to compare strings.
*** Comparison Operators
    - '==='
    - '=='
    - '>'
    - '>='
    - '<'
    - '<='

    - characters in strings are compared based on the ASCII Table

** Numbers
   
*** Creating Numbers: Part 1
    - JavaScript doesn't distinguish between integers and floating point numbers

    - Some rounding errors can occur because of the way JS stores numbers. To avoid these, consider rounding manually, or, for example, converting all decimal-based calculation to whole number calculations (i.e., instead of saying "$10.50," you can use '1050 cents.').

      #+BEGIN_SRC js
/* Numbers */

// Whole Numbers (Integers)
var a = 11,
    b = -123;

var c = 1.5,
    d = 123.456789;

var e = 0.1,
    f = 0.2;

var result = e * f; // 0.020000000000000004 (some rounding errors can occur)
      
      #+END_SRC

*** Creating Numbers: Part 2
    You can create large numbers in JavaScript, without creating large literals you your code, which could be hard to read, and error-prone.
    For example, you can use Exponential Math to represent one million:

    #+BEGIN_SRC js
// var g = 1000000;
// var g = 1E6; // easier to read than 1000000; same result in the console.
var g = 1.23E6; //1230000    
    #+END_SRC

    *begining a variable with the number '0' is not recommended, unless you want to use the octal base.*
    - Octal numbers use the power of 8, so they go 1-7, and the use 10 = 8. thus 012 = 10.
    - However, 019 = 19, because '9' is not in the octal base.
#+BEGIN_SRC js
var h = 012; // 10 (!) <-- it's an octal number, because it began with '0'.
//var h = 019 // <-- 19, because '9' is not in octal base.
#+END_SRC
      
      Hex
      ff0000 --> base 16 number: ff (R) 00 (G) 00 (B) = 255

      #+BEGIN_SRC js
//ff0000

var i = 0xff; //change the values to change the numbers in hex
      
      #+END_SRC

      Challenge answers
      #+BEGIN_SRC js
var GermanyGDP = 34E11; //3400000000000
var mevol = 020 ; // 16
      
      #+END_SRC

*** Parsing Numbers from Strings
    
**** Teacher's Notes
     
Teacher's Notes

Please note that newer browsers will return 12 for parseInt("012") and not 10. This is because the default second parameter is now 10 for decimal instead of 8 for octal.

Always specify the base if you're parsing a string to maximize compatibility.

parseInt("012", 10); //For decimal parseInt("012", 8); //For octal

**** parseInt and parseFloat
     You can use two built-in methods (functions) to parse numbers from strings.

     #+BEGIN_SRC js
var j = parseInt("197");  // 197
var jOctal = parseInt("012", 8); // 10 (Same as before; it's an octal notation because of the leading '0')
var jNineTeen = parseInt("019", 10); //1 (you should add '10' to the end of a parseInt call to make sure it's a base 10)
     #+END_SRC

     
***** parseInt("<Literal Integer>", <Radix>)
      parseInt("012", 10); // 12
*(you should add '10' to the end of a parseInt call to make sure it's a base 10)*

Be careful with NaN. Compare the lines below. Var ll begins with strings, which returns a NaN value. Var l begins with an integer, and that works.
#+BEGIN_SRC js
var k = parseInt("010111", 2); // 23 (binary)
var l = parseInt("23 people"); // 23 
var ll = parseInt("there are 23 people", 10); //NaN 
#+END_SRC

If you check to see if NaN values are equal to each other, you'll get a false answer. For example:

#+BEGIN_SRC js
NaN === NaN //false
l === l //false
l === NaN //false
#+END_SRC

#+BEGIN_SRC 
// This works for both the strict comparison ('===') or this one: ('--'). 
NaN == NaN //false
l == l //false
l == NaN //false
#+END_SRC

You an use the built-in 'isNaN' function to test for NaN:
#+BEGIN_SRC 
console.log(isNaN(l)); 
#+END_SRC

***** parseFloat();

      - parseFloat doesn't require the radix (usually base 10 for most parseInt function calls).
      - Like parseInt, parseFloat will parse a number with text if the string begins with a number. If the string begins with text, the 'NaN' error will log.

	#+BEGIN_SRC js
var m = parseFloat("123.456 is a strange number"); //123.456
var mm = parseFloat("The number 123.456 is a strange number"); // NaN
	#+END_SRC

***** Operators
      
****** Operations
       - Addition
       - Subtraction
       - Multiplication
       - Division
       - Modulo (returns the remainder of a division operation)

	 Here are some examples:
	 
      #+BEGIN_SRC js
// Operators
var o = j + k; // 220
var p = 10 - 7.3; // 2.7 (floating point numbers work fine.)
var q = 3 * 4; // 12
var r = 16 / 8; // 2
var rr = 15 / 10; // 1.5

// Modulo gives you the remainder of a division operation.
var s = 15 % 10; // 5
var ss = 30 % 10; // 0
      #+END_SRC

****** Order of Operations
JavaScript Operator Precedence Table:
       https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

       JavaScript Operator Precedence:
       - Left associative, like arithmetic.
       - Multiplication and division comes before addition and subtraction.
	 Consider 1 + 2 * 3 / 4
	 1. 2 * 3 = 6
	 2. 6 / 4 = 1.5
	 3. 1.5 + 1 = 2.5

	    #+BEGIN_SRC js
var t = 1 + 2 * 3 / 4; // 2.5
	    
	    #+END_SRC

	    You can use parentheses to group numbers and dictate the order of operations, just like in arithmetic.

	    #+BEGIN_SRC js
var t = (1 + 2) * 3 / 4; // 2.2.25
	    
	    #+END_SRC

****** Comparisons

       #+BEGIN_SRC js
console.log(1 < 2); // true
console.log(1 =< 2); // true
console.log(1 > 2); // false
console.log(1 => 2); // false
console.log(1 = 1); // true
console.log(1 >= 1); // true
console.log(1 <= 1); // true
       #+END_SRC

       You can mix integer and floating point numbers, too.

       #+BEGIN_SRC js
console.log(1 = 1.0); // true       
       #+END_SRC

       Using Equality Operators ('===' and '==')

       #+BEGIN_SRC js
console.log(1 === 1.0); // true

console.log(1 == "1"); // true
console.log(1 === "1"); // false (because === checks to see that not only are the values the same, but also that the types are. Since we've mixed strings and numbers, it's false.)
// You can make this true by using the parseInt method!

console.log(1 === parseInt("1", 10)); // true
console.log("1 === parseInt(\"1\", 10)" + (1 === parseInt("1", 10))); // "1 === parseInt("1", 10)true"

// !==
console.log(1 !== parseInt("1", 10)); // false
console.log(1 !== parseInt("2", 10)); // true
       #+END_SRC

#+BEGIN_SRC 
       if (1 < 2) {
       console.log("Yes");
       } else {
       console.log("No");
       }
#+END_SRC

****** The Math Object

#+BEGIN_SRC js
var u = Math.random(); // returns a random number between 0 and 1 (e.g., '0.3937480457587048')
#+END_SRC

#+BEGIN_SRC js
var u = Math.random() * 10; // returns a random floating point number between 1 and 10 (e.g., '3.1957870643432873')
var u = Math.round(Math.random() * 10); // returns a random integer between 1 and 10 (e.g., '7')
var v = Math.round(2.3); // returns '2'

// To always round down
var w = Math.floor(3.7); // Will always round down (e.g., '3')
var x = Math. ceil(6.2); // Will always round up (e.g., '7')
var y = Math.pow(2, 5); // Returns 2 to the power of 5. ('32')
var z = Math.sqrt(5); // Returns '2.23606797749979'

#+END_SRC

****** Math Work Archive
       /* Numbers */

// Whole Numbers (Integers)
var a = 11,
    b = -123;

var c = 1.5,
    d = 123.456789;

var e = 0.1,
    f = 0.2;

var result = e * f; // 0.020000000000000004 (some rounding errors can occur)

// var g = 1000000;
// var g = 1E6; // easier to read than 1000000; same result in the console.
var g = 1.23E6; //1230000

var h = 012; // 10 (!) <-- it's an octal number, because it began with '0'.
//var h = 019 // <-- 19, because '9' is not in octal base.

//ff0000

var i = 0xff; //change the values to change the numbers in hex

var GermanyGDP = 34E11; //3400000000000
var mevol = 020 ; // 16

////

var j = parseInt("197"); //197
var jOctal = parseInt("012", 8); // 10 (Same as before; it's an octal notation because of the leading '0')
var jNineTeen = parseInt("019", 10); //1 (you should add '10' to the end of a parseInt call to make sure it's a base 10)

var k = parseInt("010111", 2); // 23 (binary)
var l = parseInt("23 people"); // 23 
var ll = parseInt("there are 23 people", 10); //NaN 
//console.log("isNaN(l)" + isNaN(l));

var m = parseFloat("123.456 is a strange number"); //123.456
var mm = parseFloat("The number 123.456 is a strange number"); // NaN

// Operators
var o = j + k; // 220
var p = 10 - 7.3; // 2.7 (floating point numbers work fine.)
var q = 3 * 4; // 12
var r = 16 / 8; // 2
var rr = 15 / 10; // 1.5

// Modulo gives you the remainder of a division operation.
var s = 15 % 10; // 5
var ss = 30 % 10; // 0

// Order of Operations
var t = (1 + 2) * (3 / 4); // 2.25

console.log(1 < 2);

console.log("1 === parseInt(\"1\", 10)" + (1 === parseInt("1", 10)));

var u = Math.random(); // returns a random number between 0 and 1 (e.g., )
var y = Math.pow(2, 5); // Returns 2 to the power of 5. ('32')



* Arrays
** Creating Arrays
   // JavaScript Arrays
*** Literal Arrays
#+BEGIN_SRC js
var x = ['some', 'extra', 'words', 'here'];
console.log(x.length);
   #+END_SRC

   We can store arrays within arrays (sub arrays), but a sub array is only counted as one object. If we check for the length, the sub array will be counted as only one object.
   #+BEGIN_SRC js
var y = ['a string', 3, true, 'treehouse', function(a, b){return a + b;}];
console.log(y.length); // 5

var y = ['a string', 3, ['a sub array', 2, 3, 4], 'treehouse', function(a, b){return a + b;}];
console.log(y.length); // 5 
#+END_SRC
**** myArray.length
     The number of items in the array
**** Empty Arrays
    #+BEGIN_SRC js
var z [];
    
    #+END_SRC
*** The Array Constructor
Sometimes seen in code, but not something that you'll often want to do.

*new Array(length)*
Creates a new array of a given length, filled with undefined.

Useful case:
- Let's say you want to create an array with a set length (perhaps as a placeholder in code)...
  By default, the length of arrays will increase/decrease automatically. But this can be a good way to create an empty array with a set length. Here's an example:
#+BEGIN_SRC js
var a = new Array();
console.log(a); // 0

// Set the array length to 50:
var a = new Array(50);
console.log(a); // 50
#+END_SRC

** Getting and Setting

   #+BEGIN_SRC js
var my_array = ["Hello", 42, true, function (a) {return a * 2;}];
   #+END_SRC

   
*** Array Index
    - How far from the beginning of the array an element is. Arrays are accessed from the index.
    - zero based (they start at zero)

#+BEGIN_SRC js
var my_array = ["Hello", 42, true, function (a) {return a * 2;}];

var word = my_array[0]; // "Hello"
var answer = my_array[1]; // 42
var doubler = my_array[3];
console.log(doubler(10)); // 20

my_array(100); // undefined

#+END_SRC

**** Changing the value of an array
    
    #+BEGIN_SRC js
var my_array = ["Hello", 42, true, function (a) {return a * 2;}];

// To change the value of '42'
my_array[1] = 144;
var new_answer = my_array[1]; // 144
var my_array = ["Hello", 144, true, function (a) {return a * 2;}]; // the value of my_array[1] has been changed to 144.
    #+END_SRC

     If you assign a variable and the value that was used to assign that variable changes, it won't affect the other variable. In the exmaples above, the variable 'answer' was assigned the value of '42 from 'my_array\[1]', but then we changed the value of 'my_array\[1]' to 144. Note that the value of 'answer' does not change:

     #+BEGIN_SRC js
// var my_array = ["Hello", 42, true, function (a) {return a * 2;}];
var my_array = ["Hello", 144, true, function (a) {return a * 2;}];

var answer = my_array[1]; // It's still 42, because the value at the time of assignment was 42, and that doesn't change unless we explicitly change it.
     #+END_SRC

     
**** Assigning value to an index that doesn't exist
     my_array currently has an index of 3. If we define a 4th index, it will be added. If we add an index for a higher number, like 15, or 100, it will append that value, and then add 'undefined' values to each index between the index values!
     
     #+BEGIN_SRC js
my_array[4] = "A new string"; // The array was added
     
     #+END_SRC

     To add to the end of an array:
     #+BEGIN_SRC js

my_array[my_array.length] = "A new string"; // the new value will be appended to the end.
     #+END_SRC

** Methods Part 1

*** Push and Pop

**** Push
     Appends a value to an array
     "You can think of pushing a value to the end of an array"

     *myArray.toString()*
     "Returns a string representation of the array"

     #+BEGIN_SRC js
     var my_array = [2, 3, 4];
     console.log(my_array.toString()); // "2, 3, 4"
     #+END_SRC

     *myArray.push(val)*
     "Appends a value to the end of the array."

     #+BEGIN_SRC js
     var my_array = [2, 3, 4];
     myArray.push(5);
     console.log(my_array.toString()); // "2,3,4"

     console.log(my_array.toString()); // "2,3,4,5"
     #+END_SRC

     *So why use the 'toString' method?*
     It returns the array as a string, and, because of a quirk with console.log that can cause timing errors, it ensures that the string returned is accurate at the time the script runs. Compare:

     #+BEGIN_SRC js
console.log("Before the push...")
var my_array = [2, 3, 4];

console.log(my_array); // Array [ 2, 3, 4, 5 ]
console.log(my_array.toString()); // "2,3,4,"

console.log("After the push...");

my_array.push(5); // Appending '5' fo the array...

console.log(my_array); // Array [ 2, 3, 4, 5 ]
console.log(my_array.toString()); // "2,3,4,5"
     #+END_SRC
     
**** myArray.pop()
     "Removes and returns the last value in the array"

     #+BEGIN_SRC js
// my_array.pop() will pop (remove) and return the last value
var value= my_array.pop();
console.log(my_array.toString()); // "2,3,4,""
console.log("Value = ", value); // "Value = " 5
     
     #+END_SRC
     
**** Shift/Unshift
myArray.unshift(val)
"Prepends a value to the beginning of the array"
(Like myArray.push, but for the first value)

#+BEGIN_SRC js
var my_array = [2, 3, 4];
console.log("my_array before unshift: ", my_array.toString());

my_array.unshift(1);
console.log("my_array after unshift: " my_array.toString());

#+END_SRC

myArray.shift()
"Removes and returns the first value in the array"

#+BEGIN_SRC js
var my_array = [2, 3, 4];
console.log("my_array before unshift: ", my_array.toString());

my_array.unshift(1);
console.log("my_array after unshift: ", my_array.toString()); //"2,3,4"

console.log("Now, let's remove the first value from the array with myArray.shift()"); //"1,2,3,4"

var value = my_array.shift();
console.log("my_array after shift: ", my_array.toString()); //"2,3,4"
#+END_SRC


     
** Methods Part 2
   
*** Sorting

    By default, sorting arrays sorts them as if they were strings:
    #+BEGIN_SRC js
var my_array = [ 10, 44, 32, 100, 0, 44, 3, 4];
    console.log(my_array.toString()); // "10,44,32,100,0,44,3,4"

my_array.sort();
    console.log(my_array.toString()); // "0,10,100,3,32,4,44,44"
    #+END_SRC

    *myArray.sort(compareFunction)*
    "Sorts an array by using compareFunction to determine the order"
    
    To help JavaScript sort these numbers, we can create a function:
    #+BEGIN_SRC js
my_array.sort(function (a, b) {
return a - b;
});

console.log(my_array.toString()); // "0,3,4,10,32,44,44,100"
    #+END_SRC

    We could also randomie the elements in our arrays:
    #+BEGIN_SRC js
my_array.sort(function (a, b){
return Math.random() - 0.5;
})
    console.log(my_array.toString()); // "32,10,0,44,100,44,4,3" (or countless other random results)
    #+END_SRC

    *Reverse*
    We can also reverse the order of an array:
    #+BEGIN_SRC js
var my_array = [1, 2, 3, 4, 5];
console.log(my_array.toString());

my_array.reverse();
console.log(my_array.toString());
    
    #+END_SRC

*** Code Challenge
    #1: Reverse the order. Easy.
    #2: Sort the array items by length. I had to cheat and get some help from this page for saying 2

    #+BEGIN_SRC js
      var saying1 = ["The", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"];
      var saying2 = ["The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog's", "back"];
      var reverse = saying1.reverse();
      var order = saying2.sort(function(a, b) {
          a = a.toString().length; b = b.toString().length;
      return a > b ? 1 : (a < b) ? -1 : 0;
      });
    #+END_SRC

** Methods Part 3
   These methods will not change array values, so they are somewhat 'safer' methods.

   
*** myArray.concat(val1, val2, val3...)
    "Appends all of the values to the array in order"
    Note: if you pass in an array, it will add them as string items, and not as an array.
    
   #+BEGIN_SRC js
var x = [1, 2, 3];
var y = [4, 5, 6];
var z = x.concat(y); // Ths is the same as var z = x.concat(4,5,6);

console.log(x); // Array [ 1, 2, 3 ] 
console.log(y); // Array [ 4, 5, 6 ]
console.log(z); // Array [ 1, 2, 3, 4, 5, 6 ]  
   #+END_SRC

*** myArray.slice(start, end)
    "Returns a new array based on the array from index start to index end"

    #+BEGIN_SRC js
var my_array = [0, 1, 2, 3, 4, 5];
var result = my_array.slice(1, 4);

console.log(result); //Array [ 1, 2, 3 ]
    
    #+END_SRC

*** myArray.join(separator)
    "Returns a string with all values in array joined with the string separator"

    *If the values aren't a string (i.e., boolean, numbers, functions), this method will call toString, converting all values to strings, before they're added to the string.*

    #+BEGIN_SRC js
var words = ["these", "are", "some", "words"];
var result = words.join(' ');

console.log(words); // Array [ "these", "are", "some", "words" ]
console.log(result); // "these are some words"

var result = words.join('-');
console.log(result); // "these-are-some-words"
    #+END_SRC
    
** The Splice Method
   "The splice method is the most powerful method for manipulating arrays. It can perform just about any transformation, but it can be difficult to understand at first. In this video we will see how to use splice to accomplish several tasks."

   For example, if we wanted to delete '2' from my_array, we could use the delete method:
   
   #+BEGIN_SRC js
var my_array = [0, 1, 2, 3, 4, 5, 6];
console.log(my_array.toString()); // "0,1,2,3,4,5,6"

delete my_array[2];
console.log(my_array.toString()); // "0,1,,3,4,5,6"
   #+END_SRC

   The '2' position is undefined, but there's still a placeholder between '1' and '3.' Fortunately, we can use splice to remove the '2' completely, and shift the other values to the left.

      #+BEGIN_SRC js
var my_array = [0, 1, 2, 3, 4, 5, 6];
console.log(my_array.toString()); // 

my_array.splice(2, 1); // "Starting at index 2, remove 1 element."
console.log(my_array.toString()); // 
   #+END_SRC

   To add in an element, change the second argument (how many elements to remove) to '0' and add the new element:

   #+BEGIN_SRC js
var my_array = [0, 1, 2, 3, 4, 5, 6];
console.log(my_array.toString()); // "0,1,2,3,4,5,6"

my_array.splice(2, 0, 'two' ); // "Starting at index 2, don't remove anything, but insert a new element, 'two',  at index 2."
console.log(my_array.toString()); // "0,1,two,2,3,4,5,6"
   
   #+END_SRC

   We could also replace an element using this method:

   #+BEGIN_SRC js
var my_array = [0, 1, 2, 3, 4, 5, 6];
console.log(my_array.toString()); // "0,1,2,3,4,5,6"

my_array.splice(2, 1, 'two' ); // "Starting at index 2, remove 1 element (index 2), and insert a new element, 'two',  at index 2."
console.log(my_array.toString()); // "0,1,two,3,4,5,6"
   #+END_SRC

   However, we would usually just use this more convenient notation to simply change an array element:
   #+BEGIN_SRC js
my_array[2] = 'two';
   #+END_SRC

   But the splice method allows us to make many changes, very easily.
   #+BEGIN_SRC js
var my_array = [0, 1, 2, 3, 4, 5, 6];
console.log(my_array.toString()); // "0,1,2,3,4,5,6"

my_array.splice(2, 1, 'two', 'TWO', 'something else'); // 
console.log(my_array.toString()); // "0,1,two,TWO,something else,3,4,5,6"
   
   #+END_SRC

   Splice is two separate things. First, it's a way of removing one or more array elements.
   Second, it's a way to add one ore more elements at a specific index.

   #+BEGIN_SRC js
my.array (a, b, 'strings to add go here');
// a = the index
// b = the range of elements to remove. A value of '0' will not remove any elements. Otherwise, a value of '1' or higher will remove that many elements.
   #+END_SRC

* Functions
  
** Arguments
- Function Names
  "Function name must be a valid variable name"

  *"Hello World!"*
   #+BEGIN_SRC js
     function sayHello () {
         console.log("Hello World!");
     }
     
     sayHello();
   #+END_SRC

  *"Hello, World" <NAME>!
  #+BEGIN_SRC js
     function sayHello (name) {
         console.log("Hello World", name);
     }
     
     sayHello("Andrew"); // "Hello World!" "Andrew"
  
  #+END_SRC

*** Ex. 3: Adding more arguments
    #+BEGIN_SRC js
function sayHello (name, greeting) {
    if (typeof greeting === 'undefined'){
	greeting = 'Hello';
    }
    console.log(greeting, + " World", + name);
}

sayHello("Andrew", "Greetings"); // Greetings World! Andrew
sayHello("Andrew"); // Hello World! Andrew
    #+END_SRC

** Return Values
   "Our functions can calculate values that we call the return value. The return statement not only allows us to pass the value back to the caller of our function, but also stops the execution of the function itself."

   *Return Value*: "The value that the function will evaluate to when called"


   #+BEGIN_SRC js
function sayHello (name, greeting) {
    if (typeof greeting === 'undefined'){
	greeting = 'Hello'; 
    }
    console.log(greeting + " World! " + name);

    //return "Done"; // Instead of returning 'undefined' in the console, it will return 'Done'
    // return; // This will return 'undefined' in the console, but it can be useful in some cases.
    return name.length; // This will return the length of name.
}

console.log(sayHello("Andrew", "Greetings"));
console.log(sayHello("Drew"));

        
   #+END_SRC
   
   *Note*: calling Return will prevent code follwing it from running. This can be useful in an 'if' statement, for example.
   #+BEGIN_SRC js
function sayHello (name, greeting) {
    if (typeof name === 'undefined'){
	return 0; // Will prevent an 'undefined' error if the 'name' argument is undefined. (because the function tries to count the length of name.length, but you can't do that with an undefined argument.)
    }
    if (typeof greeting === 'undefined'){
	greeting = 'Hello'; 
    }
    console.log(greeting + " World! " + name);

    //return "Done"; // Instead of returning 'undefined' in the console, it will return 'Done'
    // return; // This will return 'undefined' in the console, but it can be useful in some cases.
    return name.length; // This will return the length of name.
}

console.log(sayHello("Andrew", "Greetings"));
console.log(sayHello("Drew"));
console.log(sayHello()); // This will throw an error, because you can't return the length of an undefined variable.

   #+END_SRC

   Challenge:
   #+BEGIN_SRC js
function arrayCounter (myArray){
    var arrayCount = 0;

    if (typeof myArray === 'string' || typeof myArray === 'number' || typeof myArray === 'undefined') {
	return arrayCount;
    }

    arrayCount = myArray.length;

    return arrayCount;
}
   
   #+END_SRC

** Scope
   "A new namespace for our variable"

   * Shadowing a variable
     "Creating two variables at different scopes with the same name"

     One way to avoid this issue is to name variables differently (avoid shadowing), so that variables can always be called, easily.
     

   #+BEGIN_SRC js
   
var color = 'black';
var number = 1;

function showColor () {
    var color = 'green';

    console.log('showColor color', color); // "showColor color" "green"
    console.log('showColor number', number); // 1
}

showColor(); // "green"

console.log('Global color', color); // "Global color" "black"
console.log('Global number', number); 1

   #+END_SRC

   When shadowing a variable, if you define a variable without 'var' at the beginning, you will overwrite the global variable. Use 'var' or better yet...don't shadow.

   
** Anonymous Functions
   "A function created without a name"

   #+BEGIN_SRC js

var myFunction = function (){
    console.log('myFunction was called');
}
myFuction(); // myFunction was called

   #+END_SRC

   #+BEGIN_SRC js
var myFunction = function (){
    console.log('myFunction was called');
};

var callTwice = function(targetFunction){
    targetFunction();
    targetFunction();
};

callTwice(myFunction);
   
   #+END_SRC


   #+BEGIN_SRC js

var myFunction = function (){
    console.log('myFunction was called');
};

var callTwice = function(targetFunction){
    targetFunction();
    targetFunction();
};

callTwice(function () {
    console.log("Hello from anonymous function");
});
   
   #+END_SRC

   You can use this to scope variables in JS:
   #+BEGIN_SRC js
     function tempFunction () {
         var a, b, c;
         // Code here....scoping variables is a good way to protect them
     }

tempFunction ();
   #+END_SRC

   But that's a lot of code. We could also create the function anonymously

   #+BEGIN_SRC js
     (function () {
         var a, b, c;
         // ...

     // the parentheses around the function don't make it a function; they evaluate it to that value, llke a mathematical formula. We can add the (arg1...) to it to call it.
}) (arg1, arg2) 

   #+END_SRC

   For example:

   #+BEGIN_SRC js
(function () {
var a, b, c;
// ...

console.log('from anon function');

}) (1, 'hello');
   
   #+END_SRC

   *This is a common way to create scoped variables in code, which do not interact with global variables.*

   
*** Code Challenge
    I had a lot of problems with this. I had to change the var anonoymouseFunction into an anonymous variable, and then add the '()' at the end of the function call. I'll need to study this more:

    #+BEGIN_SRC js
var anonymousFunction = function (){
};

(function() {
    window.didExecute = true;
})();    
    #+END_SRC


    I wrote this anonymous function:

    #+BEGIN_SRC js
var newFunction = function () {
    var a, b, c;

    (function() {
	console.log("This worked! I wrote my very own anonymous function!");
    });
}();

console.log(newFunction);
    
    #+END_SRC

    
** Examples (Functions)

   
*** Document Object Model (DOM)
    "The interface our code can use to interact with the web page"

    #+BEGIN_SRC js
    var button = document.getElementById('action');
var input = document.getElementById('text_field');

// oldest method; most compatible, but not considered best practice today:
button.onclick = function () {
    console.log('clicked'); // "clicked"
};

// If we want two things to happen, we can't use  onclick, because it only allows one action onclick...

button.onclick = function () {
    console.log('Other click listener');
}; // "Other click listener"

    #+END_SRC

    This will work with all browsers, but IE:

    #+BEGIN_SRC js
var button = document.getElementById('action');
var input = document.getElementById('text_field');

button.addEventListener('click', function () {
    console.log('clicked'); // "clicked"
});

button.addEventListener('click', function () {
    console.log('Other Click');
    input.setAttribute('value', 'Hello World');
});
    
    #+END_SRC
    Q: Why is it a common pattern to execute anonymous functions immediately in your program?

    A: Functions provide a new variable scope, so variables can be used privately and without collisions.


    Challenge answer:
    #+BEGIN_SRC js
function example (a, b) {
  console.log("a === ", a,  " , b === ", b);
}

example("Treehouse");

// "a === " "Treehouse" " , b === " undefined

    
    #+END_SRC
** Objects
   
   Like arrays, objects assign multiple values to a variable. But arrays assign values to a /index (number)/ key; objects assign them to /string/ keys.

   syntax: {"key": "value"}

   #+BEGIN_SRC js
var andrew = {"name": "Andrew"};

console.log(andrew.name); // "Andrew"
   #+END_SRC

   As we've seen, keys can be changed dynamically.
   #+BEGIN_SRC js
     var andrew = {"name": "Andrew"};
     console.log(andrew.name); // "Andrew"
     
     andrew.name = "Drew";
     console.log(andrew.name); // "Drew"

   #+END_SRC
   Separate commas with keys.

   #+BEGIN_SRC js
   var andrew = {
    "name": "Andrew",
    "skills": ["HTML", "CSS", "JavaScript"],
    "favorite color": "black"
};

// We can use the [ ] notation to assign variables, too.
andrew["favorite color"] = "blue";

console.log(andrew.name); // "Andrew"
console.log(andrew.skills); // [ "HTML", "CSS", "JavaScript" ]
console.log(andrew["favorite color"]); // "blue"
   #+END_SRC
*** Methods Challenge
** Call and Apply
   #+BEGIN_SRC js
   var jim = {
    name: "Jim",
    skills: ["JavaScript", "Ruby", "Dancing"],
    "favorite color": "green",
    greet: function() {
	console.log("Hello, I am " + this.name);
    }
};

var nick = {
    name: "Nick",
    greet: jim.greet
};

jim.name = "James";

jim["greet"]();
nick.greet();

var jimGreet = jim.greet;
jimGreet.call(nick)  // .call is a method that calls the method itself
jimGreet.call({name: "Amit"}) 


   #+END_SRC
*** Apply
    #+BEGIN_SRC js

var jim = {
    name: "Jim",
    skills: ["JavaScript", "Ruby", "Dancing"],
    "favorite color": "green",
    greet: function() {
	console.log("Hello, I am " + this.name);
    }
};

var nick = {
    name: "Nick",
    greet: jim.greet
};

jim.name = "James";

jim["greet"]();
nick.greet();

var jimGreet = jim.greet;
jimGreet.call(nick)  // .call is a method that calls the method itself
jimGreet.apply({name: "Amit"})  //same as .call in this case


    #+END_SRC

    Difference: how they take arguements:

    #+BEGIN_SRC js
var jim = {
    name: "Jim",
    skills: ["JavaScript", "Ruby", "Dancing"],
    "favorite color": "green",
//Notice the changes here!
    greet: function(name, mood) {
	name = name || "You";
	mood = mood || "good";
	
	console.log("Hello, " + name +
		    " I am " + this.name +
		    " and I am in a " + mood + " mood!");
    }
};

var nick = {
    name: "Nick",
    greet: jim.greet
};

jim.name = "James";

jim["greet"]("Ryan", "great");
nick.greet();


var jimGreet = jim.greet;

jimGreet.call ({name: "Amit"}, "Matt", "bad");
jimGreet.apply(nick, ["Matt", "bad"]) //apply will only take one argument + and array of other arguments


var args = ["Michael", "happy"];
jim.greet.apply(jim, args) // apply is useful when the number of arguments is unknown.

    #+END_SRC

    
